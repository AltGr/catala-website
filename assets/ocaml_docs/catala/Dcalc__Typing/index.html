<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dcalc__Typing (catala.Dcalc__Typing)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">catala</a> &#x00BB; Dcalc__Typing</nav><h1>Module <code>Dcalc__Typing</code></h1><p>Typing for the default calculus. Because of the error terms, we perform type inference using the classical W algorithm with union-find unification.</p><nav class="toc"><ul><li><a href="#types-and-unification">Types and unification</a></li><li><a href="#double-directed-typing">Double-directed typing</a></li><li><a href="#api">API</a></li></ul></nav></header><div class="spec module" id="module-Pos"><a href="#module-Pos" class="anchor"></a><code><span class="keyword">module</span> Pos = <a href="../Utils/index.html#module-Pos">Utils.Pos</a></code></div><div class="spec module" id="module-Errors"><a href="#module-Errors" class="anchor"></a><code><span class="keyword">module</span> Errors = <a href="../Utils/index.html#module-Errors">Utils.Errors</a></code></div><div class="spec module" id="module-A"><a href="#module-A" class="anchor"></a><code><span class="keyword">module</span> A = <a href="../Dcalc/index.html#module-Ast">Dcalc.Ast</a></code></div><div class="spec module" id="module-Cli"><a href="#module-Cli" class="anchor"></a><code><span class="keyword">module</span> Cli = <a href="../Utils/index.html#module-Cli">Utils.Cli</a></code></div><section><header><h2 id="types-and-unification"><a href="#types-and-unification" class="anchor"></a>Types and unification</h2></header><div class="spec module" id="module-Any"><a href="#module-Any" class="anchor"></a><code><span class="keyword">module</span> <a href="Any/index.html">Any</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-typ"><a href="#type-typ" class="anchor"></a><code><span class="keyword">type</span> typ</code><code> = </code><table class="variant"><tr id="type-typ.TLit" class="anchored"><td class="def constructor"><a href="#type-typ.TLit" class="anchor"></a><code>| </code><code><span class="constructor">TLit</span> <span class="keyword">of</span> <a href="../Dcalc/Ast/index.html#type-typ_lit">A.typ_lit</a></code></td></tr><tr id="type-typ.TArrow" class="anchored"><td class="def constructor"><a href="#type-typ.TArrow" class="anchor"></a><code>| </code><code><span class="constructor">TArrow</span> <span class="keyword">of</span> <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> * <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span></code></td></tr><tr id="type-typ.TTuple" class="anchored"><td class="def constructor"><a href="#type-typ.TTuple" class="anchor"></a><code>| </code><code><span class="constructor">TTuple</span> <span class="keyword">of</span> <span><span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> list</span> * <span><a href="../Dcalc/Ast/StructName/index.html#type-t">Dcalc.Ast.StructName.t</a> option</span></code></td></tr><tr id="type-typ.TEnum" class="anchored"><td class="def constructor"><a href="#type-typ.TEnum" class="anchor"></a><code>| </code><code><span class="constructor">TEnum</span> <span class="keyword">of</span> <span><span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> list</span> * <a href="../Dcalc/Ast/EnumName/index.html#type-t">Dcalc.Ast.EnumName.t</a></code></td></tr><tr id="type-typ.TArray" class="anchored"><td class="def constructor"><a href="#type-typ.TArray" class="anchor"></a><code>| </code><code><span class="constructor">TArray</span> <span class="keyword">of</span> <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span></code></td></tr><tr id="type-typ.TAny" class="anchored"><td class="def constructor"><a href="#type-typ.TAny" class="anchor"></a><code>| </code><code><span class="constructor">TAny</span> <span class="keyword">of</span> <a href="Any/index.html#type-t">Any.t</a></code></td></tr></table></dt><dd><p>We do not reuse <a href="../Dcalc/Ast/index.html#type-typ"><code>Ast.typ</code></a> because we have to include a new <code>TAny</code> variant. Indeed, error terms can have any type and this has to be captured by the type sytem.</p></dd></dl><dl><dt class="spec value" id="val-typ_needs_parens"><a href="#val-typ_needs_parens" class="anchor"></a><code><span class="keyword">val</span> typ_needs_parens : <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-format_typ"><a href="#val-format_typ" class="anchor"></a><code><span class="keyword">val</span> format_typ : <a href="../Dcalc/Ast/index.html#type-decl_ctx">Dcalc.Ast.decl_ctx</a> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span class="keyword">val</span> unify : <a href="../Dcalc/Ast/index.html#type-decl_ctx">Dcalc.Ast.decl_ctx</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> <span>&#45;&gt;</span> <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Raises an error if unification cannot be performed</p></dd></dl><dl><dt class="spec value" id="val-op_type"><a href="#val-op_type" class="anchor"></a><code><span class="keyword">val</span> op_type : <span><a href="../Dcalc/Ast/index.html#type-operator">A.operator</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> <span>&#45;&gt;</span> <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span></code></dt><dd><p>Operators have a single type, instead of being polymorphic with constraints. This allows us to have a simpler type system, while we argue the syntactic burden of operator annotations helps the programmer visualize the type flow in the code.</p></dd></dl><dl><dt class="spec value" id="val-ast_to_typ"><a href="#val-ast_to_typ" class="anchor"></a><code><span class="keyword">val</span> ast_to_typ : <a href="../Dcalc/Ast/index.html#type-typ">A.typ</a> <span>&#45;&gt;</span> <a href="index.html#type-typ">typ</a></code></dt><dt class="spec value" id="val-typ_to_ast"><a href="#val-typ_to_ast" class="anchor"></a><code><span class="keyword">val</span> typ_to_ast : <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> <span>&#45;&gt;</span> <span><a href="../Dcalc/Ast/index.html#type-typ">A.typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span></code></dt></dl></section><section><header><h2 id="double-directed-typing"><a href="#double-directed-typing" class="anchor"></a>Double-directed typing</h2></header><dl><dt class="spec type" id="type-env"><a href="#type-env" class="anchor"></a><code><span class="keyword">type</span> env</code><code> = <span><span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> <a href="../Dcalc__Ast/VarMap/index.html#type-t">A.VarMap.t</a></span></code></dt></dl><dl><dt class="spec value" id="val-typecheck_expr_bottom_up"><a href="#val-typecheck_expr_bottom_up" class="anchor"></a><code><span class="keyword">val</span> typecheck_expr_bottom_up : <a href="../Dcalc/Ast/index.html#type-decl_ctx">Dcalc.Ast.decl_ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-env">env</a> <span>&#45;&gt;</span> <span><a href="../Dcalc/Ast/index.html#type-expr">A.expr</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> <span>&#45;&gt;</span> <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span></code></dt><dd><p>Infers the most permissive type from an expression</p></dd></dl><dl><dt class="spec value" id="val-typecheck_expr_top_down"><a href="#val-typecheck_expr_top_down" class="anchor"></a><code><span class="keyword">val</span> typecheck_expr_top_down : <a href="../Dcalc/Ast/index.html#type-decl_ctx">Dcalc.Ast.decl_ctx</a> <span>&#45;&gt;</span> <a href="index.html#type-env">env</a> <span>&#45;&gt;</span> <span><a href="../Dcalc/Ast/index.html#type-expr">A.expr</a> <a href="../Utils/Pos/index.html#type-marked">A.Pos.marked</a></span> <span>&#45;&gt;</span> <span><span><a href="index.html#type-typ">typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> UnionFind.elem</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Checks whether the expression can be typed with the provided type</p></dd></dl></section><section><header><h2 id="api"><a href="#api" class="anchor"></a>API</h2></header><dl><dt class="spec value" id="val-infer_type"><a href="#val-infer_type" class="anchor"></a><code><span class="keyword">val</span> infer_type : <a href="../Dcalc/Ast/index.html#type-decl_ctx">Dcalc.Ast.decl_ctx</a> <span>&#45;&gt;</span> <span><a href="../Dcalc/Ast/index.html#type-expr">A.expr</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> <span>&#45;&gt;</span> <span><a href="../Dcalc/Ast/index.html#type-typ">A.typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span></code></dt><dt class="spec value" id="val-check_type"><a href="#val-check_type" class="anchor"></a><code><span class="keyword">val</span> check_type : <a href="../Dcalc/Ast/index.html#type-decl_ctx">Dcalc.Ast.decl_ctx</a> <span>&#45;&gt;</span> <span><a href="../Dcalc/Ast/index.html#type-expr">A.expr</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> <span>&#45;&gt;</span> <span><a href="../Dcalc/Ast/index.html#type-typ">A.typ</a> <a href="../Utils/Pos/index.html#type-marked">Pos.marked</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Typechecks an expression given an expected type</p></dd></dl></section></div></body></html>