<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Surface__Lexer (catala.Surface__Lexer)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">catala</a> &#x00BB; Surface__Lexer</nav><h1>Module <code>Surface__Lexer</code></h1><p>Basic lexer with abbreviated syntax, and support for localised implementations.</p></header><aside><p>Auxiliary functions used by all lexers.</p></aside><dl><dt class="spec value" id="val-is_code"><a href="#val-is_code" class="anchor"></a><code><span class="keyword">val</span> is_code : <span>bool Stdlib.ref</span></code></dt><dd><p>Boolean reference, used by the lexer as the mutable state to distinguish whether it is lexing code or law.</p></dd></dl><dl><dt class="spec value" id="val-code_string_acc"><a href="#val-code_string_acc" class="anchor"></a><code><span class="keyword">val</span> code_string_acc : <span>string Stdlib.ref</span></code></dt><dd><p>Mutable string reference that accumulates the string representation of the body of code being lexed. This string representation is used in the literate programming backends to faithfully capture the spacing pattern of the original program</p></dd></dl><dl><dt class="spec value" id="val-update_acc"><a href="#val-update_acc" class="anchor"></a><code><span class="keyword">val</span> update_acc : Sedlexing.lexbuf <span>&#45;&gt;</span> unit</code></dt><dd><p>Updates <a href="index.html#val-code_string_acc"><code>code_string_acc</code></a> with the current lexeme</p></dd></dl><dl><dt class="spec value" id="val-raise_lexer_error"><a href="#val-raise_lexer_error" class="anchor"></a><code><span class="keyword">val</span> raise_lexer_error : <a href="../Utils/Pos/index.html#type-t">Utils.Pos.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Error-generating helper</p></dd></dl><dl><dt class="spec value" id="val-token_list_language_agnostic"><a href="#val-token_list_language_agnostic" class="anchor"></a><code><span class="keyword">val</span> token_list_language_agnostic : <span><span>(string * <a href="../Surface/Tokens/index.html#type-token">Surface.Tokens.token</a>)</span> list</span></code></dt><dd><p>Associative list matching each punctuation string part of the Catala syntax with its <a href="../Surface/Parser/index.html"><code>Parser</code></a> token. Same for all the input languages (English, French, etc.)</p></dd></dl><div class="spec module-type" id="module-type-LocalisedLexer"><a href="#module-type-LocalisedLexer" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-LocalisedLexer/index.html">LocalisedLexer</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec include"><div class="doc"><p>Concise syntax with English abbreviated keywords.</p><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="index.html#module-type-LocalisedLexer">LocalisedLexer</a></code></span></summary><dl><dt class="spec value" id="val-token_list"><a href="#val-token_list" class="anchor"></a><code><span class="keyword">val</span> token_list : <span><span>(string * <a href="../Surface/Tokens/index.html#type-token">Surface.Tokens.token</a>)</span> list</span></code></dt><dd><p>Same as <a href="index.html#val-token_list_language_agnostic"><code>token_list_language_agnostic</code></a>, but with tokens whose string varies with the input language.</p></dd></dl><dl><dt class="spec value" id="val-builtins"><a href="#val-builtins" class="anchor"></a><code><span class="keyword">val</span> builtins : <span><span>(string * <a href="../Surface/Ast/index.html#type-builtin_expression">Surface.Ast.builtin_expression</a>)</span> list</span></code></dt><dd><p>Associative list of string to their corresponding builtins</p></dd></dl><dl><dt class="spec value" id="val-lex_code"><a href="#val-lex_code" class="anchor"></a><code><span class="keyword">val</span> lex_code : Sedlexing.lexbuf <span>&#45;&gt;</span> <a href="../Surface/Tokens/index.html#type-token">Surface.Tokens.token</a></code></dt><dd><p>Main lexing function used in a code block</p></dd></dl><dl><dt class="spec value" id="val-lex_law"><a href="#val-lex_law" class="anchor"></a><code><span class="keyword">val</span> lex_law : Sedlexing.lexbuf <span>&#45;&gt;</span> <a href="../Surface/Tokens/index.html#type-token">Surface.Tokens.token</a></code></dt><dd><p>Main lexing function used outside code blocks</p></dd></dl><dl><dt class="spec value" id="val-lexer"><a href="#val-lexer" class="anchor"></a><code><span class="keyword">val</span> lexer : Sedlexing.lexbuf <span>&#45;&gt;</span> <a href="../Surface/Tokens/index.html#type-token">Surface.Tokens.token</a></code></dt><dd><p>Entry point of the lexer, distributes to <a href="index.html#val-lex_code"><code>lex_code</code></a> or <a href="index.html#val-lex_law"><code>lex_law</code></a> depending of <a href="index.html#val-is_code"><code>is_code</code></a>.</p></dd></dl></details></div></div></div></div></body></html>