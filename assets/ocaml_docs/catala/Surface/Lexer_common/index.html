<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lexer_common (catala.Surface.Lexer_common)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">catala</a> &#x00BB; <a href="../index.html">Surface</a> &#x00BB; Lexer_common</nav><h1>Module <code>Surface.Lexer_common</code></h1></header><aside><p>Auxiliary functions used by all lexers.</p></aside><dl><dt class="spec value" id="val-is_code"><a href="#val-is_code" class="anchor"></a><code><span class="keyword">val</span> is_code : <span>bool Stdlib.ref</span></code></dt><dd><p>Boolean reference, used by the lexer as the mutable state to distinguish whether it is lexing code or law.</p></dd></dl><dl><dt class="spec value" id="val-code_string_acc"><a href="#val-code_string_acc" class="anchor"></a><code><span class="keyword">val</span> code_string_acc : <span>string Stdlib.ref</span></code></dt><dd><p>Mutable string reference that accumulates the string representation of the body of code being lexed. This string representation is used in the literate programming backends to faithfully capture the spacing pattern of the original program</p></dd></dl><dl><dt class="spec value" id="val-update_acc"><a href="#val-update_acc" class="anchor"></a><code><span class="keyword">val</span> update_acc : Sedlexing.lexbuf <span>&#45;&gt;</span> unit</code></dt><dd><p>Updates <a href="index.html#val-code_string_acc"><code>code_string_acc</code></a> with the current lexeme</p></dd></dl><dl><dt class="spec value" id="val-raise_lexer_error"><a href="#val-raise_lexer_error" class="anchor"></a><code><span class="keyword">val</span> raise_lexer_error : <a href="../../Utils/Pos/index.html#type-t">Utils.Pos.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Error-generating helper</p></dd></dl><dl><dt class="spec value" id="val-token_list_language_agnostic"><a href="#val-token_list_language_agnostic" class="anchor"></a><code><span class="keyword">val</span> token_list_language_agnostic : <span><span>(string * <a href="../Tokens/index.html#type-token">Tokens.token</a>)</span> list</span></code></dt><dd><p>Associative list matching each punctuation string part of the Catala syntax with its <a href="../Parser/index.html"><code>Parser</code></a> token. Same for all the input languages (English, French, etc.)</p></dd></dl><dl><dt class="spec value" id="val-calc_precedence"><a href="#val-calc_precedence" class="anchor"></a><code><span class="keyword">val</span> calc_precedence : string <span>&#45;&gt;</span> int</code></dt><dd><p>Calculates the precedence according a matched regex of the form : '<code>#</code>+'</p></dd></dl><dl><dt class="spec value" id="val-get_law_heading"><a href="#val-get_law_heading" class="anchor"></a><code><span class="keyword">val</span> get_law_heading : Sedlexing.lexbuf <span>&#45;&gt;</span> <a href="../Tokens/index.html#type-token">Tokens.token</a></code></dt><dd><p>Gets the <code>LAW_HEADING</code> token from the current <code>lexbuf</code></p></dd></dl><div class="spec module-type" id="module-type-LocalisedLexer"><a href="#module-type-LocalisedLexer" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-LocalisedLexer/index.html">LocalisedLexer</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>